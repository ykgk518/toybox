# learn-Refactoring

## 1章

### 着手前のコメント

* 規模が大きくなると、1つの関数だけでは理解が難しくなる
* コンパイラはコードが汚いとかきれいだとか一切気にしない
* 変更には人間の作業が加わり、きれいさを気にする
* 設計がまずい＝変更が難しい
* 変更すべき箇所がわかりにくい→新たなバグを埋め込む可能性大

* プログラムの変更を行うとき、まず何をするか
  1. **関数やその他のプログラム上の要素を利用し、**
  2. **コードを構造化された形にして、**
  3. **プログラムが何を行っているかを容易に理解できるようにしていく。**

* **構造的に機能を加えにくいプログラムに新規機能を追加しなければならない場合には、 まず機能追加が簡単になるようにリファクタリングをしてから追加すること。** 


### リファクタリングの第一歩
* リファクタリングを行うとき、最初にすることは常に同じである
  * それは**テスト群を作り上げること**

* **リファクタリングに入る前に、しっかりとした一連のテスト群を用意しておくこと。 これらのテストには自己診断機能が不可欠である。**
* 変更を加えたらすかさずコンパイルしてテストを行う

### statement関数の分割

* **長い関数をリファクタリングするときは、全体をいくつかに分割できる箇所を探す**

* 理解したことをコードに埋め込んでいく方法とは、意味のあるコードの塊を関数にして、何をしているかを端的に示す名前を付けること。

* **リファクタリングでは小さなステップでプログラムを変更していく。そのため間違ってもバグを見つけるのは簡単である。**

* **コンパイラがわかるコードは誰にでも書ける。すぐれたプログラマは人間にとってわかりやすいコードを書く。**

#### 変更によるパフォーマンスへの影響について

* ほとんどの場合、ループの繰り返しでは、パフォーマンスには影響を与えない
* リファクタリングによって、 パフォーマンスに重大な影響を及ぼしてしまうこともときにはあります。 
  * たとえそうなったとしても、 私はかまわず作業を継続します。 
  * なぜならよく整理されたコードのほうが、 後からパフォーマンスの最適化  がしやすいからです。 
  * リファクタリングの結果、重大なパフォーマンス上の問題が出た場合、後  でパフォーマンスチューニングのために時間を割きます。 
  * もしかしたら速度のために、 リファクタリングした箇所を元に戻さなければならないかもしれません。
  * しかし、 たいていの場合はリファクタリングによって、より効果的なパフォーマンスチューニングが施しやすくなっています。
  * 結局は明確で速いコードが実現できる



### 現況:入れ子になった関数がたくさん


### 計算とフォーマットにフェーズを分割


### 現況:2つのファイル(フェーズ)への分離


### 型による計算処理の再編成

### 現況:ポリモーフィックなCalculatorでデータを作成

* 良いコードかどうかは、 変更がどれだけ容易なのかで決まる。 
